Index: src/movement/movement.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n    ID gruppo : 51\r\n\r\n    886711 Passarella-Diego | 882082 Pasqual-Davide | 881493 Ravagnan-Michelle\r\n\r\n */\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n#include <string.h>\r\n#include <time.h>\r\n#include <unistd.h>\r\n\r\n#include \"../colors/colors.h\"\r\n#include \"../game_engine/game_engine.h\"\r\n#include \"../ia/ia.h\"\r\n#include \"../memory_management/memory_management.h\"\r\n#include \"movement.h\"\r\n#include \"../user_interaction/user_interaction.h\"\r\n\r\nunsigned int move_noeat(player_t *players, unsigned int num_pawn, char *str, board_t *board, unsigned int nPl){\r\n    if(!strcmp(str,\"sx\")){\r\n        if((is_in(players[nPl].pawns[num_pawn].coordinate.y-1,players[nPl].pawns[num_pawn].coordinate.x-(players[nPl].pawns[num_pawn].dim_label+3+1),*board))&&(!check_spot(*board,players[nPl].pawns[num_pawn].coordinate.y-1,players[nPl].pawns[num_pawn].coordinate.x-(players[nPl].pawns[num_pawn].dim_label+3+1),(players[nPl].pawns[num_pawn].dim_label+3+1)))){\r\n            remove_pawn(board,players[nPl].pawns[num_pawn].coordinate.y,players[nPl].pawns[num_pawn].coordinate.x,(players[nPl].pawns[num_pawn].dim_label+3+1));\r\n            --players[nPl].pawns[num_pawn].coordinate.y;\r\n            players[nPl].pawns[num_pawn].coordinate.x -= (players[nPl].pawns[num_pawn].dim_label+3+1);\r\n            pawn_promotion(players,num_pawn,nPl,board->n_rows-1);\r\n            return 1;\r\n        }else{\r\n            return 0;\r\n        }\r\n    }else{\r\n        if (!strcmp(str, \"dx\")) {\r\n            if((is_in(players[nPl].pawns[num_pawn].coordinate.y-1, players[nPl].pawns[num_pawn].coordinate.x + (players[nPl].pawns[num_pawn].dim_label + 3+1), *board))&&(!check_spot(*board, players[nPl].pawns[num_pawn].coordinate.y - 1, players[nPl].pawns[num_pawn].coordinate.x + (players[nPl].pawns[num_pawn].dim_label + 3+1),players[nPl].pawns[num_pawn].dim_label+3+1))){\r\n                remove_pawn(board,players[nPl].pawns[num_pawn].coordinate.y,players[nPl].pawns[num_pawn].coordinate.x,(players[nPl].pawns[num_pawn].dim_label+3+1));\r\n                --players[nPl].pawns[num_pawn].coordinate.y;\r\n                players[nPl].pawns[num_pawn].coordinate.x += (players[nPl].pawns[num_pawn].dim_label+3+1);\r\n                pawn_promotion(players,num_pawn,nPl,board->n_rows-1);\r\n                return 1;\r\n            }else{\r\n                return 0;\r\n            }\r\n        }\r\n        if (!strcmp(str, \"bassosx\") && ((nPl == 1) || (players[nPl].pawns[num_pawn].isPromoted))) {\r\n            if((is_in(players[nPl].pawns[num_pawn].coordinate.y+1,players[nPl].pawns[num_pawn].coordinate.x-(players[nPl].pawns[num_pawn].dim_label+3+1),*board))&&(!check_spot(*board,players[nPl].pawns[num_pawn].coordinate.y+1,players[nPl].pawns[num_pawn].coordinate.x-(players[nPl].pawns[num_pawn].dim_label+3+1),(players[nPl].pawns[num_pawn].dim_label+3+1)))){\r\n                remove_pawn(board,players[nPl].pawns[num_pawn].coordinate.y,players[nPl].pawns[num_pawn].coordinate.x,(players[nPl].pawns[num_pawn].dim_label+3+1));\r\n                players[nPl].pawns[num_pawn].coordinate.y++;\r\n                players[nPl].pawns[num_pawn].coordinate.x -= (players[nPl].pawns[num_pawn].dim_label+3+1);\r\n                if(nPl == 1){\r\n                    pawn_promotion(players,num_pawn,nPl,board->n_rows-1);\r\n                }\r\n                return 1;\r\n            }else{\r\n                return 0;\r\n            }\r\n        }\r\n        if (!strcmp(str, \"bassodx\") && ((nPl == 1) || (players[nPl].pawns[num_pawn].isPromoted))) {\r\n            if((is_in(players[nPl].pawns[num_pawn].coordinate.y+1, players[nPl].pawns[num_pawn].coordinate.x + (players[nPl].pawns[num_pawn].dim_label + 3+1), *board))&&(!check_spot(*board, players[nPl].pawns[num_pawn].coordinate.y+1, players[nPl].pawns[num_pawn].coordinate.x + (players[nPl].pawns[num_pawn].dim_label + 3+1),players[nPl].pawns[num_pawn].dim_label + 3+1))){\r\n                remove_pawn(board,players[nPl].pawns[num_pawn].coordinate.y,players[nPl].pawns[num_pawn].coordinate.x,(players[nPl].pawns[num_pawn].dim_label+3+1));\r\n                players[nPl].pawns[num_pawn].coordinate.y++;\r\n                players[nPl].pawns[num_pawn].coordinate.x += (players[nPl].pawns[num_pawn].dim_label+3+1);\r\n                if(nPl == 1){\r\n                    pawn_promotion(players,num_pawn,nPl,board->n_rows-1);\r\n                }\r\n                return 1;\r\n            }else{\r\n                return 0;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nunsigned int eat(player_t *players, char *str, unsigned int num_pawn, board_t board, unsigned int enemy_pawn, unsigned int nPl){\r\n\r\n    unsigned int nPl2 = 1, i;\r\n    char temp[3];\r\n\r\n    if (nPl == 1){\r\n        nPl2 = 0;\r\n    }\r\n\r\n    temp[0] = players[nPl].pawns[num_pawn].label[1];\r\n    temp[1] = players[nPl].pawns[num_pawn].label[2];\r\n    temp[2] = players[nPl2].pawns[enemy_pawn].label[players[nPl2].pawns[enemy_pawn].cima]; /* 012 */\r\n\r\n    if (players[nPl2].pawns[enemy_pawn].grade == 1){\r\n        players[nPl2].pawns[enemy_pawn].grade = 0;\r\n    }else if((players[nPl2].pawns[enemy_pawn].grade > 1) && players[nPl2].pawns[enemy_pawn].label[players[nPl2].pawns[enemy_pawn].cima] == players[nPl2].pawns[enemy_pawn].label[players[nPl2].pawns[enemy_pawn].cima+1]){\r\n        players[nPl2].pawns[enemy_pawn].label[players[nPl2].pawns[enemy_pawn].cima] = ' ';\r\n        players[nPl2].pawns[enemy_pawn].cima+=1;\r\n        players[nPl2].pawns[enemy_pawn].grade-=1;\r\n    }else{\r\n        int newPos = is_empty(players[nPl]);\r\n        if (newPos == -1){\r\n            add_pawn(players, enemy_pawn, nPl,players[nPl].pawns[num_pawn].label[players[nPl].pawns[num_pawn].cima]);\r\n        }else if(newPos >= 0 && players[nPl2].pawns[enemy_pawn].grade > 1){\r\n            int newPos_copy;\r\n            unsigned int index;\r\n            players[nPl2].pawns[enemy_pawn].label[players[nPl2].pawns[enemy_pawn].cima] = ' ';\r\n            players[nPl2].pawns[enemy_pawn].cima+=1;\r\n            players[nPl2].pawns[enemy_pawn].grade-=1;\r\n            players[nPl].pawns[newPos].grade = players[nPl2].pawns[enemy_pawn].grade;\r\n            players[nPl2].pawns[enemy_pawn].grade = 0;\r\n            players[nPl].pawns[newPos].cima = players[nPl2].pawns[enemy_pawn].cima;\r\n\r\n            players[nPl].pawns[newPos].coordinate.x = players[nPl2].pawns[enemy_pawn].coordinate.x;\r\n            players[nPl].pawns[newPos].coordinate.y = players[nPl2].pawns[enemy_pawn].coordinate.y;\r\n\r\n            players[nPl].pawns[newPos].dim_label = players[nPl2].pawns[enemy_pawn].dim_label;\r\n\r\n            players[nPl].pawns[newPos].isPromoted = 0;\r\n            players[nPl2].pawns[enemy_pawn].isPromoted = 0;\r\n            players[nPl2].pawns[newPos].label[players[nPl].pawns[newPos].dim_label+3] = ' ';\r\n            players[nPl].pawns[newPos].label[players[nPl].pawns[newPos].dim_label+3] = ' ';\r\n\r\n            for (i = 0; i < 3; i++){\r\n                players[nPl].pawns[newPos].label[i] = players[nPl2].pawns[enemy_pawn].label[i];\r\n            }\r\n            index = players[nPl].pawns[newPos].dim_label-1;\r\n            newPos_copy = newPos;\r\n            for (i = 3; i < players[nPl].pawns[newPos].dim_label+3; i++){\r\n                players[nPl].pawns[newPos].label[i] = int_converter(newPos_copy, index);\r\n                newPos_copy -= (pow(10, index)*(players[nPl].pawns[newPos].label[i] - '0'));\r\n\r\n                index--;\r\n            }\r\n\r\n        }\r\n        \r\n    }\r\n    if (players[nPl].pawns[num_pawn].grade < 3){\r\n        for (i = 0; i < 3; i++){\r\n            players[nPl].pawns[num_pawn].label[i] = temp[i];\r\n        }\r\n        players[nPl].pawns[num_pawn].cima-=1;\r\n        players[nPl].pawns[num_pawn].grade+=1;\r\n    }\r\n    remove_pawn(&board,players[nPl2].pawns[enemy_pawn].coordinate.y,players[nPl2].pawns[enemy_pawn].coordinate.x,players[nPl2].pawns[enemy_pawn].dim_label+3+1);\r\n    if(!strcmp(str,\"sx\")){\r\n        players[nPl].pawns[num_pawn].coordinate.y -= 2;\r\n        players[nPl].pawns[num_pawn].coordinate.x -= (players[nPl].pawns[num_pawn].dim_label+3+1)*2;\r\n    }\r\n    if(!strcmp(str,\"dx\")){\r\n        players[nPl].pawns[num_pawn].coordinate.y -= 2;\r\n        players[nPl].pawns[num_pawn].coordinate.x += (players[nPl].pawns[num_pawn].dim_label+3+1)*2;\r\n    }\r\n    if(!strcmp(str,\"bassosx\")){\r\n        players[nPl].pawns[num_pawn].coordinate.y += 2;\r\n        players[nPl].pawns[num_pawn].coordinate.x -= (players[nPl].pawns[num_pawn].dim_label+3+1)*2;\r\n    }\r\n    if(!strcmp(str,\"bassodx\")){\r\n        players[nPl].pawns[num_pawn].coordinate.y += 2;\r\n        players[nPl].pawns[num_pawn].coordinate.x += (players[nPl].pawns[num_pawn].dim_label+3+1)*2;\r\n    }\r\n\r\n    if(!strcmp(str,\"sx\")){\r\n        remove_pawn(&board,players[nPl].pawns[num_pawn].coordinate.y+2,players[nPl].pawns[num_pawn].coordinate.x+((players[nPl].pawns[num_pawn].dim_label+3+1)*2),players[nPl].pawns[num_pawn].dim_label+3+1);\r\n    }\r\n    if(!strcmp(str,\"dx\")){\r\n        remove_pawn(&board,players[nPl].pawns[num_pawn].coordinate.y+2,players[nPl].pawns[num_pawn].coordinate.x-((players[nPl].pawns[num_pawn].dim_label+3+1)*2),(players[nPl].pawns[num_pawn].dim_label+3+1));\r\n    }\r\n    if(!strcmp(str,\"bassosx\")){\r\n        remove_pawn(&board,players[nPl].pawns[num_pawn].coordinate.y-2,players[nPl].pawns[num_pawn].coordinate.x+((players[nPl].pawns[num_pawn].dim_label+3+1)*2),players[nPl].pawns[num_pawn].dim_label+3+1);\r\n    }\r\n    if(!strcmp(str,\"bassodx\")){\r\n        remove_pawn(&board,players[nPl].pawns[num_pawn].coordinate.y-2,players[nPl].pawns[num_pawn].coordinate.x-((players[nPl].pawns[num_pawn].dim_label+3+1)*2),(players[nPl].pawns[num_pawn].dim_label+3+1));\r\n    }\r\n    pawn_promotion(players,num_pawn,nPl,board.n_rows-1);\r\n    return 1;\r\n}\r\n\r\nint move_p1 (player_t *players, unsigned int num_pawn, char *str, board_t *board, unsigned int nPl){\r\n    int enemy_pawn;\r\n    enemy_pawn = can_eat(players,num_pawn,str,board, nPl);\r\n    if(enemy_pawn > -1){\r\n        eat(players, str, num_pawn, *board, enemy_pawn, nPl);\r\n        return enemy_pawn;\r\n    }else if(enemy_pawn == -4){\r\n        printf(\"Errore nella can_eat\\n\");\r\n    }else if(move_noeat(players, num_pawn, str, board, nPl)){\r\n        return -1;\r\n    }else{\r\n        return -2;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nint move_p2(player_t *players,unsigned int num_pawn,char *str,board_t *board){\r\n    if(!strcmp(str,\"sx\")) {\r\n        return move_p1(players,num_pawn,\"bassosx\",board,1);\r\n    }else{\r\n        if(!strcmp(str,\"dx\")){\r\n            return move_p1(players,num_pawn,\"bassodx\",board,1);\r\n        }\r\n        if(!strcmp(str,\"bassodx\")&&(players[1].pawns[num_pawn].isPromoted)) {\r\n            return move_p1(players,num_pawn,\"dx\",board,1);\r\n        }\r\n        if(!strcmp(str,\"bassosx\")&&(players[1].pawns[num_pawn].isPromoted)) {\r\n            return move_p1(players,num_pawn,\"sx\",board,1);\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/movement/movement.c b/src/movement/movement.c
--- a/src/movement/movement.c	(revision 955d9f8fc0d6d0d765e7da7201ec6cad5d798857)
+++ b/src/movement/movement.c	(date 1610813362854)
@@ -95,7 +95,8 @@
     }else{
         int newPos = is_empty(players[nPl]);
         if (newPos == -1){
-            add_pawn(players, enemy_pawn, nPl,players[nPl].pawns[num_pawn].label[players[nPl].pawns[num_pawn].cima]);
+            printf("SERVE\n");
+            /*add_pawn(players, enemy_pawn, nPl,players[nPl].pawns[num_pawn].label[players[nPl].pawns[num_pawn].cima]);*/
         }else if(newPos >= 0 && players[nPl2].pawns[enemy_pawn].grade > 1){
             int newPos_copy;
             unsigned int index;
Index: src/user_interaction/user_interaction.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n    ID gruppo : 51\r\n\r\n    886711 Passarella-Diego | 882082 Pasqual-Davide | 881493 Ravagnan-Michelle\r\n\r\n */\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n#include <string.h>\r\n#include <time.h>\r\n#include <unistd.h>\r\n\r\n#include \"../colors/colors.h\"\r\n#include \"../game_engine/game_engine.h\"\r\n#include \"../ia/ia.h\"\r\n#include \"../memory_management/memory_management.h\"\r\n#include \"../movement/movement.h\"\r\n#include \"user_interaction.h\"\r\n\r\nvoid print_board(board_t t,unsigned int cifre, unsigned npl, char char_p1, char char_p2){\r\n    int i, j, k = 0, z, l;\r\n    char *topPl = (char*) malloc((t.n_cols)*sizeof(char));\r\n    int *cime = (int*) malloc((t.n_cols)*sizeof(int));\r\n    /* stampo prima riga */\r\n    for(j=0; j<t.n_cols; j +=cifre){\r\n        printf(\"+\");\r\n        for(z = 0 ; z < cifre+2; ++z){ /* 2 = spazio a destra e sinistra */\r\n            printf(\"-\");\r\n        }\r\n    }\r\n    printf(\"+\");/* recupero angolo dx */\r\n    printf(\"\\n\");\r\n\r\n    /* parte centrale */\r\n    if(npl == 0){\r\n        i = 0;\r\n    }else{\r\n        i = t.n_rows-1;\r\n    }\r\n    while( (((npl == 0)&&(i < t.n_rows))||((npl == 1)&&(i >= 0))) ){\r\n        for (l = 0; l < t.n_cols; l+=cifre){\r\n            /* controllo dov'è la cima */      \r\n            while (t.mat[i][l+k] != char_p2 && t.mat[i][l+k] != char_p1 && k<3){\r\n                k++;\r\n            }\r\n            cime[l/cifre] = k;\r\n            /* indica il possessore della torre */\r\n            topPl[l/cifre] = t.mat[i][l+k];\r\n            k=0;\r\n        }\r\n        \r\n        for (l = 0; l < 3; l++){\r\n            for(j=0; j<t.n_cols; j +=cifre){\r\n                printf(\"|\");\r\n                /* stampa le torri */\r\n                if (cime[j/cifre]==l){\r\n                    if (topPl[j/cifre] == char_p2 || topPl[j/cifre] == char_p1){\r\n                        setBlack();\r\n                        if (topPl[j/cifre] == char_p2){\r\n                            printColor(char_p2);\r\n                        }else if (topPl[j/cifre] == char_p1){\r\n                            printColor(char_p1);\r\n                        }\r\n                        printf(\" \");\r\n                        for (z = 0; z < cifre; z++){\r\n                            /*printf(\"%c\",t.mat[i][j+z]);*/ /* STAMPA CARATTERI DELLA MATRICE */\r\n                            if(t.mat[i][j+z] == char_p1){\r\n                                printf(\"%c\",'B');\r\n                            }else{\r\n                                if(t.mat[i][j+z] == char_p2){ /* STAMPA SEMPRE CARATTERI B/N A SECONDA DEL PLAYER*/\r\n                                    printf(\"%c\",'N');\r\n                                }else{\r\n                                    printf(\"%c\",t.mat[i][j+z]);\r\n                                }\r\n                            }\r\n\r\n                        }\r\n                        printf(\" \");\r\n                        resetColor();\r\n                    }\r\n                }else{\r\n                    if (cime[j/cifre]<l){\r\n                        if ((t.mat[i][j+l] == char_p1 || t.mat[i][j+l] == char_p2) && t.mat[i][j+l] != topPl[j/cifre]){\r\n                            if (topPl[j/cifre] == char_p2){\r\n                                printColor(char_p1);\r\n                            }else if (topPl[j/cifre] == char_p1){\r\n                                printColor(char_p2);\r\n                            }\r\n                            /* altrimenti stampa il colore del proprietario */\r\n                        }else{\r\n                            if (topPl[j/cifre] == char_p2){\r\n                                printColor(char_p2);\r\n                            }else if (topPl[j/cifre] == char_p1){\r\n                                printColor(char_p1);\r\n                            }\r\n                        }\r\n                        for(z = 0 ; z < cifre+2; ++z){\r\n                            printf(\" \");\r\n                        }\r\n                        resetColor();\r\n                    }    /* stampa le caselle bianche */\r\n                    else if (topPl[j/cifre] == '#' || (cime[j/cifre]!=3)){\r\n                        setWhite();\r\n                        for(z = 0 ; z < cifre+2; ++z){\r\n                            printf(\" \");\r\n                        }\r\n                        resetColor();\r\n                    }\r\n                    /* stampa le caselle nere */\r\n                    else{\r\n                        for(z = 0 ; z < cifre+2; ++z){\r\n                            printf(\" \");\r\n                        }\r\n                    }\r\n                }          \r\n            }\r\n            printf(\"|\\n\");\r\n        }\r\n        \r\n        /* stampa separatore tra righe */\r\n        if(((npl == 0)&&(i != t.n_rows-1))||((npl == 1)&&(i != 0))){\r\n            printf(\"|\");\r\n            for(j=0; j<t.n_cols; j +=cifre){\r\n                if(j != 0){\r\n                    printf(\"+\");\r\n                }\r\n                for(z = 0 ; z < cifre+2 ; ++z){\r\n                    printf(\"-\");\r\n                }\r\n            }\r\n            printf(\"|\\n\");\r\n        }\r\n\r\n        if(npl == 0){\r\n            ++i;\r\n        }else{\r\n            --i;\r\n        }\r\n    }\r\n\r\n    /* stampa la base */\r\n    for(j=0; j<t.n_cols; j +=cifre){\r\n        printf(\"+\");\r\n        for(z = 0 ; z < cifre+2 ; ++z){\r\n            printf(\"-\");\r\n        }\r\n    }\r\n    printf(\"+\");/* recupero angolo dx */\r\n    printf(\"\\n\");\r\n\r\n    free(cime);\r\n    free(topPl);\r\n}\r\n\r\nvoid print_player(player_t *players,unsigned int nPl){\r\n    unsigned int i,j;\r\n    for(i = 0 ; i < players[nPl].dim_pawns; ++i){\r\n        if (players[nPl].pawns[i].grade>0){\r\n            printf(\"Pedina = \");\r\n            for(j = 0 ; j < 3+players[nPl].pawns[i].dim_label+1 ;++j ){\r\n                printf(\"%c\",players[nPl].pawns[i].label[j]);\r\n            }\r\n            printf(\"\\n\");\r\n            if (players[nPl].pawns[i].isPromoted){\r\n                print_directions(players[nPl].pawns[i].canMove, 4, i);\r\n            }else\r\n            {\r\n                print_directions(players[nPl].pawns[i].canMove, 2, i);\r\n                \r\n            }       \r\n            printf(\"Cima = %d\\n\",players[nPl].pawns[i].cima);\r\n            printf(\"grade pedina : %d \\n\",players[nPl].pawns[i].grade);\r\n            printf(\"Posizione nel campo x: %d, y: %d\\n\",players[nPl].pawns[i].coordinate.x,players[nPl].pawns[i].coordinate.y);\r\n            /*printf(\"Posizione nel campo x: %d, y: %d\\n\",(x/6)+1,(y)+1);*/\r\n            printf(\"Promozione pedina : %u\\n\",players[nPl].pawns[i].isPromoted);\r\n            printf(\"\\n\");\r\n        }\r\n    }\r\n}\r\nunsigned int while_select_nPawn(player_t *players,unsigned int nPl){\r\n    unsigned int nPawn;\r\n    printf(\"Numero di pedina da selezionare : \");\r\n    scanf(\"%u\",&nPawn);\r\n\r\n    while(!check_while(players, nPl,nPawn) ){\r\n        unsigned int flag = 1;\r\n        if (nPl == 1 || nPl == 0 ){\r\n            flag = check_canMove(players, nPawn,nPl);\r\n        }\r\n        if(!flag){\r\n            printf(\"La pedina %u non puo' muoversi!\\n\",nPawn);\r\n            printf(\"Numero di pedina da selezionare : \");\r\n            scanf(\"%u\",&nPawn);\r\n        }\r\n\r\n    }\r\n    return nPawn;\r\n}\r\nunsigned int round_player(player_t *players,board_t *t,unsigned int nPl){\r\n    char str[10];\r\n    unsigned int num_Pawn = 0;\r\n    int y = -2;\r\n\r\n    update_board(t,players);\r\n    print_board(*t,(players[0].pawns[0].dim_label+3)+1,nPl, players[0].color, players[1].color);\r\n\r\n    printf(\"Vuoi uscire dal gioco ? \");\r\n    scanf(\"%s\",str);\r\n    if((!strcmp(str,\"si\"))||(!strcmp(str,\"Si\"))||(!strcmp(str,\"SI\"))){\r\n        return 3;\r\n    }\r\n\r\n    num_Pawn = while_select_nPawn(players,nPl);\r\n    printf(\"Vuoi selezionare questa pedina %u ? \",num_Pawn);\r\n    scanf(\"%s\",str);\r\n\r\n    while( (!strcmp(str,\"no\"))||(!strcmp(str,\"NO\"))||(!strcmp(str,\"No\")) ){\r\n        num_Pawn = while_select_nPawn(players,nPl);\r\n        printf(\"Vuoi selezionare questa pedina %u ? \",num_Pawn);\r\n        scanf(\"%s\",str);\r\n    }\r\n\r\n    while(y==-2){\r\n        unsigned int tentativi = 3;\r\n        if(nPl == 1 || nPl == 0 ){\r\n            unsigned int index = 2;\r\n            players[nPl].pawns[num_Pawn].isPromoted ? index = 4 : index;\r\n            print_directions(players[nPl].pawns[num_Pawn].canMove,index,num_Pawn);\r\n        }\r\n        printf(\"Verso che direzione vuoi spostare la pedina %u? \",num_Pawn);\r\n        scanf(\"%s\",str);\r\n        if(nPl == 1 || nPl == 0){\r\n            unsigned int index = 2;\r\n            players[nPl].pawns[num_Pawn].isPromoted ? index = 4 : index;\r\n            while(!check_directions(players[nPl].pawns[num_Pawn].canMove,index,str) && tentativi != 0){\r\n                printf(\"Tentativi rimasti prima di selezione un'altra pedina : %u\\n\",tentativi);\r\n                printf(\"Verso che direzione vuoi spostare la pedina %u? \",num_Pawn);\r\n                scanf(\"%s\",str);\r\n                --tentativi;\r\n            }\r\n            if(!tentativi){\r\n                y = -3;\r\n            }\r\n        }\r\n        if(nPl == 0 && y != -3){\r\n            y = move_p1(players,num_Pawn,str,t,nPl);\r\n        }\r\n        if(nPl == 1 && y != -3){\r\n            y = move_p2(players, num_Pawn, str, t);\r\n        }\r\n        if(y < -1){\r\n            char temp[2];\r\n            y = -2;\r\n            printf(\"Seleziona un'altra pedina\\n\");\r\n            num_Pawn = while_select_nPawn(players,nPl);\r\n\r\n            printf(\"Vuoi selezionare questa pedina %d ? \",num_Pawn);\r\n            scanf(\"%s\",temp);\r\n\r\n            while( (!strcmp(str,\"no\"))||(!strcmp(str,\"NO\"))||(!strcmp(str,\"No\")) ){\r\n                num_Pawn = while_select_nPawn(players,nPl);\r\n                printf(\"Vuoi selezionare questa pedina %u ? \",num_Pawn);\r\n                scanf(\"%s\",str);\r\n            }\r\n        }\r\n    }\r\n    update_board(t,players);\r\n    if(nPl == 1 || nPl == 0){\r\n        print_board(*t,(players[nPl].pawns[num_Pawn].dim_label+3)+1,1, players[0].color, players[1].color);\r\n    }\r\n\r\n    return 4;\r\n}\r\nunsigned int round_choice(){\r\n    char str[2];\r\n\r\n    printf(\"Inizia il turno come da predefinito (quindi primo giocatore)? \");\r\n    scanf(\"%s\",str);\r\n    if((!strcmp(str,\"si\"))||(!strcmp(str,\"Si\"))||(!strcmp(str,\"SI\"))){\r\n        return 0;\r\n    }else{\r\n        printf(\"Lancio monetina ? \");\r\n        scanf(\"%s\",str);\r\n        if((!strcmp(str,\"no\"))||(!strcmp(str,\"NO\"))||(!strcmp(str,\"No\")) ){\r\n            unsigned int npl = 0;\r\n            printf(\"Giocatore 1 o 2 inizia per primo? : \");\r\n            scanf(\"%u\",&npl);\r\n            while(npl != 1 && npl != 2){\r\n                printf(\"Quale giocatore inizia per primo(1/2) ? \");\r\n                scanf(\"%u\",&npl);\r\n            }\r\n\r\n            return npl-1;\r\n        }\r\n        if((!strcmp(str,\"si\"))||(!strcmp(str,\"Si\"))||(!strcmp(str,\"SI\"))){\r\n            int x = 0 ;\r\n            srand(time(NULL));\r\n            while(x == 0){\r\n                x = rand()%10;\r\n            }\r\n            if(x%2 == 0){\r\n                x = 0;\r\n            }else{\r\n                x = 1;\r\n            }\r\n            return x;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\nint game(unsigned int gameMode){\r\n    board_t *t = NULL;\r\n    player_t *players = NULL;\r\n    int isCustom, depth;\r\n    unsigned int exit = 4,turno = 0,round = 0;\r\n    unsigned int cifre,conta = 2,numped = 11;\r\n\r\n    srand(time(0));\r\n\r\n    if (gameMode){\r\n        printf(\"\\n\\tSelect difficulty: \\n\\n\");\r\n        printf(\" [0] \"GRN\"Easy\"reset\"   (random IA)\\n\");\r\n        printf(\" [1] \"YEL\"Medium\"reset\" (low-depth minimax)\\n\");\r\n        printf(\" [2] \"RED\"Hard\"reset\"   (high-depth minimax)\\n\");\r\n        printf(\" [3] Custom (custom-depth minimax)\\n\");\r\n        printf(\"\\n Selection: \");\r\n\r\n        scanf(\"%d\", &depth);\r\n        if (depth == 1){\r\n            depth = 5;\r\n            printf(\" Selected \"YEL\"medium\"reset\".\\n\");\r\n        }else if(depth == 2){\r\n            depth = 11;\r\n            printf(\" Selected \"RED\"hard\"reset\".\\n\");\r\n        }else if (depth == 3){\r\n            printf(\" Select depth: \");\r\n            scanf(\"%d\", &depth);\r\n            while(depth%2 == 0 ){\r\n                printf(\" Depth deve essere numero dispari\\n\");\r\n                printf(\" Select depth: \");\r\n                scanf(\"%d\", &depth);\r\n            }\r\n        }else{\r\n            depth = 0;\r\n            printf(\" Selected\"GRN\"easy\"reset\".\\n\");\r\n        }\r\n    \r\n    }\r\n    \r\n    printf(\"\\n\\tSelect gamemode:\\n\");\r\n    printf(\" [0] Classic (11 vs 11, board 7x7)\\n\");\r\n    printf(\" [1] Custom\\n\");\r\n    printf(\"\\n Selection: \");\r\n\r\n    scanf(\"%d\", &isCustom);\r\n    \r\n\r\n    if(isCustom == 0){\r\n        t = create_board(7,7,3+conta+1);\r\n        initialize_board(t,3+conta+1);\r\n        players = create_pawns(11,'Y','R',conta,*t); /* create array[2] of player_t type */\r\n    }else{\r\n        unsigned int w,h,max_ped = 0;\r\n        char char_p1, char_p2;\r\n        conta = 0;\r\n        printf(\"Altezza della scacchiera : \");\r\n        scanf(\"%u\",&h);\r\n        printf(\"Larghezza della scacchiera : \");\r\n        scanf(\"%u\",&w);\r\n\r\n        while(w < 3 || h < 3){\r\n            printf(\"Larghezza e altezza della scacchiera non soddisfa requisiti minimi(h >= 3,w >= 3)\\n\");\r\n            printf(\"Reinserire altezza e larghezza\\n \");\r\n            printf(\"Altezza della scacchiera : \");\r\n            scanf(\"%u\",&h);\r\n            printf(\"Larghezza della scacchiera : \");\r\n            scanf(\"%u\",&w);\r\n        }\r\n        max_ped = max_pawns(h,w);\r\n        printf(\"Numero di pedine massimo per giocatore : %u\\n\",max_ped);\r\n        printf(\"Numero pedine ?(ovviamente minore o guale al massimo numero) : \");\r\n        scanf(\"%u\",&cifre);\r\n        while(cifre > max_ped){\r\n            printf(\"Reinserire numero pedine : \");\r\n            scanf(\"%u\",&cifre);\r\n        }\r\n\r\n\r\n        numped = cifre;\r\n        \r\n        if(cifre > 0) {\r\n            while (cifre != 0) {\r\n                cifre /= 10;\r\n                ++conta;\r\n            }\r\n            if ((pow(10, conta - 1) == numped) && (numped != 1)) {\r\n                --conta;\r\n            }\r\n            t = create_board(h,w,3+conta+1);\r\n            initialize_board(t,3+conta+1);\r\n\r\n\r\n            printf(\"[\" RED \"R\" reset \"] [\" GRN \"G\" reset \"] [\"MAG \"M\" reset \"] [\"BLU \"B\" reset \"] [\"CYN \"C\" reset \"] [\"YEL \"Y\" reset \"]\\n\");\r\n\r\n            printf(\"Seleziona colore pedina Player1: \");\r\n            scanf(\"%s\", &char_p1);\r\n            if(check_char_color(char_p1) == 2){\r\n                char temp;\r\n                temp = uppercase(char_p1);\r\n                char_p1 = temp;\r\n            }\r\n\r\n            printf(\"Seleziona colore pedina Player2: \");\r\n            scanf(\"%s\", &char_p2);\r\n            if(check_char_color(char_p2) == 2){\r\n                char temp;\r\n                temp = uppercase(char_p2);\r\n                char_p2 = temp;\r\n            }\r\n\r\n\r\n            while(check_char_color(char_p1)!=1 || check_char_color(char_p2)!=1){\r\n                if(!check_char_color(char_p1) ){\r\n                    printf(\"Hai sbagliato ad inserire carattere Player 1\\n\");\r\n                    printf(\"Seleziona colore pedina Player1: \");\r\n                    scanf(\"%s\", &char_p1);\r\n                }else{\r\n                    if(check_char_color(char_p1) == 2){\r\n                        char temp;\r\n                        temp = uppercase(char_p1);\r\n                        char_p1 = temp;\r\n                    }\r\n                }\r\n                if(!check_char_color(char_p2)){\r\n                    printf(\"Hai sbagliato ad inserire carattere Player n\\n\");\r\n                    printf(\"Seleziona colore pedina Player2: \");\r\n                    scanf(\"%s\", &char_p2);\r\n                }else{\r\n                    printf(\"%u\",check_char_color(char_p2));\r\n                    if(check_char_color(char_p2) == 2){\r\n                        char temp;\r\n                        temp = uppercase(char_p2);\r\n                        char_p2 = temp;\r\n                    }\r\n                }\r\n            }\r\n\r\n            players = create_pawns(numped,char_p1, char_p2, conta,*t); /* create array[2] of player_t type */\r\n            print_player(players,0);\r\n            print_player(players,1);\r\n\r\n        }else{\r\n            printf(\"Non ha senso giocare con %u pedine !\\n\",cifre);\r\n            return 0;\r\n        }\r\n    }\r\n\r\n     turno = round_choice();\r\n    printf(\"Il player che inizia e' %u\\n\",turno+1);\r\n    while((exit == 4)&&(is_victory(players)>2)){\r\n        set_moves_pawn(players,t,0,-1);\r\n        set_moves_pawn(players,t,1,-1);\r\n        if( all_blocked(players,turno) ){\r\n            unsigned int turno_next = 1;\r\n            if(turno){\r\n                turno_next = 0;\r\n            }\r\n            if(all_blocked(players,turno_next)){\r\n                exit = 2;\r\n            }else{\r\n                exit = turno;\r\n            }\r\n        }\r\n        if(exit == 4){\r\n            printf(\"Round numero : %u\\n\",round);\r\n            printTextColor(players[turno].color);\r\n            printf(\"Turno Player %d\\n\", turno+1);\r\n            resetColor();\r\n            if (turno == 0 ){\r\n                exit = round_player(players,t,turno);\r\n                turno = 1;\r\n            }else{\r\n                if (gameMode){\r\n                    if (depth == 0){\r\n                        exit = round_ia_random(players, t, turno);\r\n                    }else{\r\n                        exit = round_ia_minimax(players,t,turno, depth);                \r\n                    }                \r\n                }else{            \r\n                    exit = round_player(players,t,turno);\r\n                }\r\n                turno = 0;\r\n            }\r\n            /* print_player(players,0);\r\n            print_player(players,1); */\r\n            update_board(t, players);\r\n            print_board(*t, players[turno].pawns[0].dim_label+1+3, 0, players[0].color, players[1].color);\r\n            /*printMatrix(*t);*/\r\n            sleep(0);\r\n            ++round;\r\n        }\r\n    }\r\n    if(exit == 2){\r\n        printf(\"Entrambi i giocatori hanno le pedine bloccate\\n\");\r\n    }\r\n    if(exit == 3){\r\n        printf(\"Hai abbandonato la partita\\n\");\r\n    }else{\r\n        if(exit == 1 || exit  == 0){\r\n            ++exit;\r\n        }\r\n        if(exit == 4){\r\n            exit = is_victory(players);\r\n        }\r\n        printf(\"Round totali della partita : %u\\n\",round);\r\n        printf(\"Il vincitore e' il player %d!\\n\",exit);\r\n    }\r\n\r\n    destroy_board(t);\r\n    destroy_player(players);\r\n\r\n    return 1;\r\n}\r\n\r\nvoid menu(){\r\n    int choice = 0;\r\n    system(\"clear\");\r\n    printf(\" #886711 Diego    Passarella\\n\");\r\n    printf(\" #882082 Davide   Pasqual\\n\");\r\n    printf(\" #881493 Michelle Ravagnan\\n\");\r\n    printf(\"\\n\\t+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n\"\r\n             \"\\t|\"\"M|\"\"i|\"\"n|\"\"i||\"\"L|\"\"a|\"\"s|\"\"k|\"\"a|  |\"\"5|\"\"1|\"\"\\n\"\r\n             \"\\t+-+-+-+-+-+-+-+-+-+-+-+-+-+\");\r\n    printf(\"\\n\\n [1] Player vs. Player\");\r\n    printf(\"\\n [2] Player vs. IA\");\r\n    printf(\"\\n [3] Exit\");\r\n    while(choice != 1 && choice != 2 && choice != 3){\r\n        printf(\"\\n\\n Select mode: \");\r\n        scanf(\"%d\", &choice);\r\n        switch(choice){\r\n            case 1:\r\n                system(\"clear\");\r\n                printf(\"\\nSelected Player vs. Player\\n\");\r\n                game(0);\r\n                break;\r\n            case 2:\r\n                printf(\"\\nSelected Player vs. IA\\n\");\r\n                system(\"clear\");\r\n                game(1);\r\n                break;\r\n            case 3:\r\n                system(\"clear\");\r\n                break;\r\n            default:\r\n                printf(\"\\nINVALID SELECTION...Please try again\\n\");\r\n        };\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/user_interaction/user_interaction.c b/src/user_interaction/user_interaction.c
--- a/src/user_interaction/user_interaction.c	(revision 955d9f8fc0d6d0d765e7da7201ec6cad5d798857)
+++ b/src/user_interaction/user_interaction.c	(date 1610815539668)
@@ -172,7 +172,6 @@
             printf("Cima = %d\n",players[nPl].pawns[i].cima);
             printf("grade pedina : %d \n",players[nPl].pawns[i].grade);
             printf("Posizione nel campo x: %d, y: %d\n",players[nPl].pawns[i].coordinate.x,players[nPl].pawns[i].coordinate.y);
-            /*printf("Posizione nel campo x: %d, y: %d\n",(x/6)+1,(y)+1);*/
             printf("Promozione pedina : %u\n",players[nPl].pawns[i].isPromoted);
             printf("\n");
         }
@@ -344,7 +343,7 @@
             }
         }else{
             depth = 0;
-            printf(" Selected"GRN"easy"reset".\n");
+            printf(" Selected "GRN"easy"reset".\n");
         }
     
     }
@@ -438,7 +437,6 @@
                     printf("Seleziona colore pedina Player2: ");
                     scanf("%s", &char_p2);
                 }else{
-                    printf("%u",check_char_color(char_p2));
                     if(check_char_color(char_p2) == 2){
                         char temp;
                         temp = uppercase(char_p2);
@@ -470,7 +468,7 @@
             if(all_blocked(players,turno_next)){
                 exit = 2;
             }else{
-                exit = turno;
+                exit = turno_next;
             }
         }
         if(exit == 4){
@@ -508,10 +506,10 @@
     if(exit == 3){
         printf("Hai abbandonato la partita\n");
     }else{
-        if(exit == 1 || exit  == 0){
+        if(exit == 1 || exit == 0){
             ++exit;
         }
-        if(exit == 4){
+        if(exit == 4 ){
             exit = is_victory(players);
         }
         printf("Round totali della partita : %u\n",round);
